-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mskmysht/graphlib-hs#readme</a>
@package graphlib-hs
@version 0.1.0.1

module GT.Graph.Class
type Pair n = (n, n)
type NodeId = Int
type EdgeId = Pair NodeId
type With i v = (i, v)
type NWith n = With NodeId n
type EWith e = With EdgeId e
data Direction
Directed :: Direction
Undirected :: Direction
class Directing (d :: Direction)
ppair :: Directing d => Proxy d -> NodeId -> NodeId -> EdgeId
pisSource :: Directing d => Proxy d -> NodeId -> EdgeId -> Bool
pisSink :: Directing d => Proxy d -> NodeId -> EdgeId -> Bool
pdirection :: Directing d => Proxy d -> Direction
opposite :: NodeId -> EdgeId -> Maybe NodeId
opposite' :: NodeId -> EdgeId -> NodeId
class Unwrap i w => Wrap i v w
wrap :: Wrap i v w => i -> v -> w
wfoldr :: (Wrap i v w, Foldable f) => (i -> v -> r -> r) -> r -> f w -> r
class Unwrap i w
unwrap :: Unwrap i w => w -> i
class (Directing d, Wrap NodeId n n', Unwrap NodeId n', Wrap EdgeId e e', Unwrap EdgeId e') => Graph g n n' e e' d | g -> n n' e e' d
pair :: Graph g n n' e e' d => g -> NodeId -> NodeId -> EdgeId
isSource :: Graph g n n' e e' d => g -> NodeId -> EdgeId -> Bool
isSink :: Graph g n n' e e' d => g -> NodeId -> EdgeId -> Bool
direction :: Graph g n n' e e' d => g -> Direction
nodeCount :: Graph g n n' e e' d => g -> Int
edgeCount :: Graph g n n' e e' d => g -> Int
removeEdge :: Graph g n n' e e' d => NodeId -> NodeId -> g -> g
getNode :: Graph g n n' e e' d => NodeId -> g -> n'
getNodeValue :: Graph g n n' e e' d => NodeId -> g -> n
getEdge :: Graph g n n' e e' d => EdgeId -> g -> e'
getEdgeValue :: Graph g n n' e e' d => EdgeId -> g -> e
nodes :: (Graph g n n' e e' d, Cons (t n') (t n') n' n', Monoid (t n')) => g -> t n'
edges :: (Graph g n n' e e' d, Cons (t e') (t e') e' e', Monoid (t e')) => g -> t e'
nodeMap :: (Graph g n n' e e' d, Cons (t r) (t r) r r, Monoid (t r)) => (n' -> r) -> g -> t r
edgeMap :: (Graph g n n' e e' d, Cons (t r) (t r) r r, Monoid (t r)) => (e' -> r) -> g -> t r
adjMap :: (Graph g n n' e e' d, Cons (t r) (t r) r r, Monoid (t r)) => (n' -> e' -> r) -> NodeId -> g -> Maybe (t r)
adjNodeMap :: (Graph g n n' e e' d, Cons (t r) (t r) r r, Monoid (t r)) => (n' -> r) -> NodeId -> g -> Maybe (t r)
adjFoldl :: Graph g n n' e e' d => (r -> n' -> e' -> r) -> r -> NodeId -> g -> Maybe r
adjNodeFoldl :: Graph g n n' e e' d => (r -> n' -> r) -> r -> NodeId -> g -> Maybe r
adjFoldlM :: (Graph g n n' e e' d, Monad m) => (r -> n' -> e' -> m r) -> r -> NodeId -> g -> MaybeT m r
adjForM_ :: (Graph g n n' e e' d, Monad m) => NodeId -> g -> (n' -> e' -> m r) -> MaybeT m ()
degree :: Graph g n n' e e' d => NodeId -> g -> Maybe Int
class Builder g n e | g -> n e
assoc :: (Builder g n e, Foldable f1, Foldable f2, Wrap NodeId n n', Wrap EdgeId e e') => f1 n' -> f2 e' -> g
build :: (Builder g n e, Traversable t1, Traversable t2) => t1 NodeId -> (NodeId -> n) -> t2 EdgeId -> (NodeId -> NodeId -> e) -> g
instance GHC.Show.Show GT.Graph.Class.Direction
instance GT.Graph.Class.Wrap i v (GT.Graph.Class.With i v)
instance GT.Graph.Class.Wrap a a a
instance GT.Graph.Class.Unwrap i (GT.Graph.Class.With i v)
instance (a Data.Type.Equality.~ b) => GT.Graph.Class.Unwrap a b
instance GT.Graph.Class.Directing 'GT.Graph.Class.Directed
instance GT.Graph.Class.Directing 'GT.Graph.Class.Undirected

module GT.Algorithm.Propagation
propagate :: forall d n n' g e e' a m s. (Graph g n n' e e' d, PrimMonad m, Pointed s, Foldable s, Monoid (s NodeId)) => (e' -> Double) -> g -> (s NodeId -> s NodeId -> a -> a) -> a -> MonadGen m -> StateT (s NodeId, s NodeId) m a
propagateUntil :: forall d n n' g e e' a m s. (Graph g n n' e e' d, Pointed s, Foldable s, Monoid (s NodeId)) => (e' -> Double) -> g -> (s NodeId -> s NodeId -> a -> a) -> (a -> Bool) -> s NodeId -> a -> Int -> (a, (s NodeId, s NodeId))

module GT.Algebra.Matrix
adjacencyMatrix :: Graph (g d) n n' e e' d => g d -> Matrix R
degreeMatrix :: Graph (g d) n n' e e' d => g d -> Matrix R
laplacianMatrix :: Graph (g d) n n' e e' d => g d -> Matrix R

module GT.Graph.Internal
data G nc n n' ec e e' (d :: Direction)
G :: !Int -> !Int -> !Int -> !nc n -> !ec e -> Proxy d -> G nc n n' ec e e'
[nid] :: G nc n n' ec e e' -> !Int
[nc] :: G nc n n' ec e e' -> !Int
[ec] :: G nc n n' ec e e' -> !Int
[ns] :: G nc n n' ec e e' -> !nc n
[es] :: G nc n n' ec e e' -> !ec e
[prx] :: G nc n n' ec e e' -> Proxy d
type VGr n e = G (Map NodeId) n (NWith n) (HashMap EdgeId) e (EWith e)
type DiVGr n e = VGr n e  'Directed
type UndiVGr n e = VGr n e  'Undirected
type NVGr n = G (Map NodeId) n (NWith n) Set EdgeId EdgeId
type DiNVGr n = NVGr n  'Directed
type UndiNVGr n = NVGr n  'Undirected
type EVGr e = G Set NodeId NodeId (HashMap EdgeId) e (EWith e)
type DiEVGr e = EVGr e  'Directed
type UndiEVGr e = EVGr e  'Undirected
type Gr = G Set NodeId NodeId Set EdgeId EdgeId
type DiGr = Gr  'Directed
type UndiGr = Gr  'Undirected
type MapGr n e = VGr n e
type DiMapGr n e = MapGr n e  'Directed
type UndiMapGr n e = MapGr n e  'Undirected
type BasicGr = Gr
type DiBasicGr = BasicGr  'Directed
type UndiBasicGr = BasicGr  'Undirected
_adjCombinator :: f -> NodeId -> ns -> es -> (NodeId -> ns -> Bool) -> (NodeId -> n') -> (NodeId -> es -> es) -> ((EdgeId -> n') -> f -> es -> a) -> Maybe a
oppositeV' :: (Wrap NodeId n n', SemiIndexable NodeId nc n) => nc n -> NodeId -> EdgeId -> n'
filterWithSource :: (SemiFilterable EdgeId ec e, Directing d) => Proxy d -> ec e -> NodeId -> ec e
_adjFCombinator :: (SemiFoldable NodeId nc n, SemiIndexable NodeId nc n, SemiFilterable EdgeId ec e, Directing d, Wrap EdgeId e e', Wrap NodeId n n') => Proxy d -> nc n -> ec e -> ((a -> EdgeId -> e -> b) -> q -> ec e -> r) -> (a -> n' -> e' -> b) -> q -> NodeId -> Maybe r
_adjMCombinator :: (SemiFoldable NodeId nc n, SemiIndexable NodeId nc n, SemiFilterable EdgeId ec e, Directing d, Wrap EdgeId e e', Wrap NodeId n n') => Proxy d -> nc n -> ec e -> ((EdgeId -> e -> b) -> ec e -> r) -> (n' -> e' -> b) -> NodeId -> Maybe r
class Foldable f => SemiFoldable i f v
selem :: SemiFoldable i f v => i -> f v -> Bool
sfoldl :: SemiFoldable i f v => (r -> i -> v -> r) -> r -> f v -> r
sfoldr :: SemiFoldable i f v => (i -> v -> r -> r) -> r -> f v -> r
sfoldlM :: (SemiFoldable i f v, Monad m) => (r -> i -> v -> m r) -> r -> f v -> m r
sforM_ :: (SemiFoldable i f v, Monad m) => f v -> (i -> v -> m r) -> m ()
convert :: (SemiFoldable i f v, Monoid (t r), Cons (t r) (t r) r r) => (i -> v -> r) -> f v -> t r
class SemiFilterable i f v
sfilter :: SemiFilterable i f v => (i -> Bool) -> f v -> f v
class SemiIndexable i t v
sindex :: SemiIndexable i t v => t v -> i -> v
class SemiTraversable i t v
sfor :: (SemiTraversable i t v, Applicative f) => t v -> (i -> v -> f r) -> f (t r)
sforM :: (SemiTraversable i t v, Monad m) => t v -> (i -> v -> m r) -> m (t r)
type SemiWitherable i t v = (SemiFoldable i t v, SemiFilterable i t v, SemiTraversable i t v)
type SemiFFI i t v = (SemiFoldable i t v, SemiFilterable i t v, SemiIndexable i t v)
class (Foldable nc, Monoid (nc n)) => NodeBuilderBase nc n
_nassoc' :: (NodeBuilderBase nc n, Foldable f, Wrap NodeId n n', SemiFoldable EdgeId ec e) => f n' -> ec e -> (Int, Int, nc n)
class (Monoid (ec e), SemiFoldable EdgeId ec e) => EdgeBuilderBase d ec e
_eassoc' :: (EdgeBuilderBase d ec e, Foldable f, Wrap EdgeId e e') => Proxy d -> f e' -> (Int, ec e)
_cnassoc' :: (Foldable f, Foldable nc, Monoid (nc NodeId), Wrap NodeId NodeId n', SemiFoldable EdgeId ec e, Cons (nc NodeId) (nc NodeId) NodeId NodeId) => f n' -> ec e -> (Int, Int, nc NodeId)
_nassoc :: (Foldable f, Foldable nc, Monoid (nc n), Wrap NodeId n n', SemiFoldable EdgeId ec e) => (NodeId -> n -> nc n -> nc n) -> (NodeId -> nc n -> nc n) -> f n' -> ec e -> (Int, Int, nc n)
_eassoc :: (Directing d, Foldable f, Monoid (ec e), SemiFoldable EdgeId ec e, Wrap EdgeId e e') => Proxy d -> (EdgeId -> e -> ec e -> ec e) -> f e' -> (Int, ec e)
instance GT.Graph.Class.Directing d => GT.Graph.Internal.EdgeBuilderBase d Data.Set.Internal.Set GT.Graph.Class.EdgeId
instance GT.Graph.Class.Directing d => GT.Graph.Internal.EdgeBuilderBase d Data.HashSet.Base.HashSet GT.Graph.Class.EdgeId
instance GT.Graph.Class.Directing d => GT.Graph.Internal.EdgeBuilderBase d (Data.Map.Internal.Map GT.Graph.Class.EdgeId) e
instance GT.Graph.Class.Directing d => GT.Graph.Internal.EdgeBuilderBase d (Data.HashMap.Base.HashMap GT.Graph.Class.EdgeId) e
instance (GT.Graph.Class.Directing d, GT.Graph.Class.Wrap GT.Graph.Class.NodeId n n', GT.Graph.Class.Wrap GT.Graph.Class.EdgeId e e', GT.Graph.Internal.NodeBuilderBase nc n, GT.Graph.Internal.EdgeBuilderBase d ec e, GT.Graph.Internal.SemiFoldable GT.Graph.Class.EdgeId ec e) => GT.Graph.Class.Builder (GT.Graph.Internal.G nc n n' ec e e' d) n e
instance GT.Graph.Internal.NodeBuilderBase Data.Set.Internal.Set GT.Graph.Class.NodeId
instance GT.Graph.Internal.NodeBuilderBase Data.HashSet.Base.HashSet GT.Graph.Class.NodeId
instance GT.Graph.Internal.NodeBuilderBase (Data.Map.Internal.Map GT.Graph.Class.NodeId) n
instance GT.Graph.Internal.NodeBuilderBase (Data.HashMap.Base.HashMap GT.Graph.Class.NodeId) n
instance GT.Graph.Internal.NodeBuilderBase [] GT.Graph.Class.NodeId
instance GT.Graph.Internal.NodeBuilderBase Data.Sequence.Internal.Seq GT.Graph.Class.NodeId
instance GT.Graph.Internal.NodeBuilderBase Data.Vector.Vector GT.Graph.Class.NodeId
instance (GT.Graph.Class.Directing d, GT.Graph.Class.Wrap GT.Graph.Class.NodeId n n', GT.Graph.Class.Unwrap GT.Graph.Class.NodeId n', GT.Graph.Internal.SemiFFI GT.Graph.Class.NodeId nc n, GT.Graph.Class.Wrap GT.Graph.Class.EdgeId e e', GT.Graph.Class.Unwrap GT.Graph.Class.EdgeId e', GT.Graph.Internal.SemiFFI GT.Graph.Class.EdgeId ec e) => GT.Graph.Class.Graph (GT.Graph.Internal.G nc n n' ec e e' d) n n' e e' d
instance (GHC.Classes.Eq a, Data.Traversable.Traversable t) => GT.Graph.Internal.SemiTraversable a t a
instance (GHC.Classes.Eq i, Control.Lens.Indexed.TraversableWithIndex i (t i)) => GT.Graph.Internal.SemiTraversable i (t i) a
instance forall k e e' (nc :: * -> *) n (ec :: * -> *) (n' :: k) (d :: GT.Graph.Class.Direction). (GT.Graph.Class.Wrap GT.Graph.Class.EdgeId e e', GT.Graph.Internal.SemiIndexable GT.Graph.Class.NodeId nc n, GT.Graph.Internal.SemiFoldable GT.Graph.Class.EdgeId ec e, GHC.Show.Show n, GHC.Show.Show e, GHC.Show.Show e') => GHC.Show.Show (GT.Graph.Internal.G nc n n' ec e e' d)
instance GT.Graph.Internal.SemiIndexable a t a
instance (GHC.Classes.Eq i, Control.Lens.Indexed.TraversableWithIndex i (t i)) => GT.Graph.Internal.SemiIndexable i (t i) a
instance (GHC.Classes.Eq a, Data.Witherable.Filterable f) => GT.Graph.Internal.SemiFilterable a f a
instance GHC.Classes.Eq a => GT.Graph.Internal.SemiFilterable a Data.Set.Internal.Set a
instance GHC.Classes.Eq a => GT.Graph.Internal.SemiFilterable a Data.HashSet.Base.HashSet a
instance (GHC.Classes.Eq i, Data.Witherable.FilterableWithIndex i (f i)) => GT.Graph.Internal.SemiFilterable i (f i) a
instance forall k e e' (ec :: * -> *) (nc :: * -> *) (n' :: k) (d :: GT.Graph.Class.Direction). (GT.Graph.Class.Wrap GT.Graph.Class.EdgeId e e', GT.Graph.Internal.SemiFoldable GT.Graph.Class.EdgeId ec e, GHC.Show.Show e, GHC.Show.Show e') => GHC.Show.Show (GT.Graph.Internal.G nc GT.Graph.Class.NodeId n' ec e e' d)
instance (GHC.Classes.Eq a, Data.Foldable.Foldable f) => GT.Graph.Internal.SemiFoldable a f a
instance (GHC.Classes.Eq i, Control.Lens.Indexed.FoldableWithIndex i (f i)) => GT.Graph.Internal.SemiFoldable i (f i) a

module GT.Graph
type UndiBasicGr = BasicGr  'Undirected
type DiBasicGr = BasicGr  'Directed
type BasicGr = Gr
type UndiMapGr n e = MapGr n e  'Undirected
type DiMapGr n e = MapGr n e  'Directed
type MapGr n e = VGr n e
type UndiGr = Gr  'Undirected
type DiGr = Gr  'Directed
type Gr = G Set NodeId NodeId Set EdgeId EdgeId
type UndiEVGr e = EVGr e  'Undirected
type DiEVGr e = EVGr e  'Directed
type EVGr e = G Set NodeId NodeId (HashMap EdgeId) e (EWith e)
type UndiNVGr n = NVGr n  'Undirected
type DiNVGr n = NVGr n  'Directed
type NVGr n = G (Map NodeId) n (NWith n) Set EdgeId EdgeId
type UndiVGr n e = VGr n e  'Undirected
type DiVGr n e = VGr n e  'Directed
type VGr n e = G (Map NodeId) n (NWith n) (HashMap EdgeId) e (EWith e)

module GT.Generator.RandomGraph
barabasiAlbert :: forall d m n' e' g n e. (PrimMonad m, Builder g n e, Graph g n n' e e' d) => Int -> Int -> Int -> (NodeId -> n) -> (NodeId -> NodeId -> e) -> ExceptT String m g

module GT.Algorithm.ShortestPath
dijkstra :: forall d w g n n' e e'. (Ord w, Num w, Graph g n n' e e' d) => (e' -> w) -> NodeId -> NodeId -> g -> Maybe (w, Seq NodeId)

module GT.Parse
parseGraphml :: (Graph g n n' e e' d, Builder g n e) => (NodeId -> Map String String -> n) -> (NodeId -> NodeId -> Maybe Int -> Map String String -> e) -> String -> Either String g
