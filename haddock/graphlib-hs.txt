-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mskmysht/graphlib-hs#readme</a>
@package graphlib-hs
@version 0.1.0.0

module GT.Graph.Class
type NodeId = Int
type NWith n = (NodeId, n)
type Pair n = (n, n)
type PairWith n e = (n, n, e)
data IsDirect
Directed :: IsDirect
Undirected :: IsDirect
newtype C (d :: IsDirect)
C :: Pair NodeId -> C
[decouple] :: C -> Pair NodeId
class Couple (d :: IsDirect)
couple :: Couple d => NodeId -> NodeId -> C d
isSource :: Couple d => NodeId -> C d -> Bool
isSink :: Couple d => NodeId -> C d -> Bool
opposite :: NodeId -> C d -> NodeId
class Unwrap i w => Wrap i v w
wrap :: Wrap i v w => i -> v -> w
class Unwrap i w
unwrap :: Unwrap i w => w -> i
class Direction g (d :: IsDirect)
isDirect :: Direction g d => g d -> Bool
class Traversable t => Graph g t n' e' | g -> t n' e'
nodes :: Graph g t n' e' => g -> t n'
edges :: Graph g t n' e' => g -> t e'
nodeSize :: Graph g t n' e' => g -> Int
edgeSize :: Graph g t n' e' => g -> Int
nodeCont :: Graph g t n' e' => g -> (n' -> r) -> t r
edgeCont :: Graph g t n' e' => g -> (e' -> r) -> t r
adjNodeCont :: Graph g t n' e' => NodeId -> g -> (n' -> r) -> Maybe (t r)
adjNodeFold :: Graph g t n' e' => NodeId -> g -> (r -> n' -> r) -> r -> Maybe r
fromId :: Graph g t n' e' => NodeId -> g -> n'
removeEdge :: Graph g t n' e' => NodeId -> NodeId -> g -> g
degree :: Graph g t n' e' => NodeId -> g -> Maybe Int
findNodeIndex :: (Graph g t n' e', Eq n') => n' -> g -> Maybe Int
pairCont :: (Traversable t, Graph g t n' (Pair NodeId)) => g -> (NodeId -> NodeId -> r) -> t r
class (Traversable t, Graph g t n' (PairWith n' e)) => EdgeAccessor g t n' e | g -> n' e
toPairs :: (EdgeAccessor g t n' e, Eq e) => e -> g -> t (Pair NodeId)
adjCont :: EdgeAccessor g t n' e => NodeId -> g -> (n' -> e -> r) -> Maybe (t r)
adjContM_ :: (EdgeAccessor g t n' e, Monad m) => NodeId -> g -> (n' -> e -> m r) -> m (Maybe ())
adjFold :: EdgeAccessor g t n' e => NodeId -> g -> (r -> n' -> e -> r) -> r -> Maybe r
adjFoldM :: (EdgeAccessor g t n' e, Monad m) => NodeId -> g -> (r -> n' -> e -> m r) -> r -> MaybeT m r
fromPair :: EdgeAccessor g t n' e => Pair NodeId -> g -> e
class Couple d => Builder g d
assoc :: Builder g d => [n] -> [PairWith NodeId e] -> g n e d
build :: Builder g d => (NodeId -> n) -> Int -> [PairWith NodeId (NodeId -> NodeId -> e)] -> g n e d
class Couple d => BasicBuilder g d
assocB :: BasicBuilder g d => Int -> [Pair NodeId] -> g d
instance GT.Graph.Class.Direction g 'GT.Graph.Class.Directed
instance GT.Graph.Class.Direction g 'GT.Graph.Class.Undirected
instance GT.Graph.Class.Wrap GT.Graph.Class.NodeId n (GT.Graph.Class.NWith n)
instance GT.Graph.Class.Wrap (GT.Graph.Class.Pair n') e (GT.Graph.Class.PairWith n' e)
instance GT.Graph.Class.Wrap a a a
instance GT.Graph.Class.Unwrap GT.Graph.Class.NodeId (GT.Graph.Class.NWith n)
instance GT.Graph.Class.Unwrap (GT.Graph.Class.Pair n') (GT.Graph.Class.PairWith n' e)
instance GT.Graph.Class.Unwrap a a
instance GT.Graph.Class.Unwrap i n' => GT.Graph.Class.Unwrap (GT.Graph.Class.Pair i) (GT.Graph.Class.Pair n')
instance GT.Graph.Class.Couple 'GT.Graph.Class.Directed
instance GT.Graph.Class.Couple 'GT.Graph.Class.Undirected

module GT.Graph
type BasicGr = SGr Set Set NodeId (Pair NodeId)
type MapGr = SGr IntMap (HashMap (Pair NodeId))
type DiBasicGr = BasicGr  'Directed
type UndiBasicGr = BasicGr  'Undirected
type DiMapGr n e = MapGr n e  'Directed
type UndiMapGr n e = MapGr n e  'Undirected
instance (GHC.Show.Show n, GHC.Show.Show e) => GHC.Show.Show (GT.Graph.MapGr n e d)
instance (GT.Graph.Class.Wrap GT.Graph.Class.NodeId n (GT.Graph.Class.NWith n), GT.Graph.Class.Couple d) => GT.Graph.Class.Graph (GT.Graph.MapGr n e d) Data.Sequence.Internal.Seq (GT.Graph.Class.NWith n) (GT.Graph.Class.PairWith (GT.Graph.Class.NWith n) e)
instance (GT.Graph.Class.Wrap GT.Graph.Class.NodeId n (GT.Graph.Class.NWith n), GT.Graph.Class.Couple d) => GT.Graph.Class.EdgeAccessor (GT.Graph.MapGr n e d) Data.Sequence.Internal.Seq (GT.Graph.Class.NWith n) e
instance GT.Graph.Class.Couple d => GT.Graph.Class.Builder GT.Graph.MapGr d
instance GHC.Show.Show (GT.Graph.BasicGr d)
instance GT.Graph.Class.Couple d => GT.Graph.Class.Graph (GT.Graph.BasicGr d) Data.Sequence.Internal.Seq GT.Graph.Class.NodeId (GT.Graph.Class.Pair GT.Graph.Class.NodeId)
instance GT.Graph.Class.Couple d => GT.Graph.Class.BasicBuilder GT.Graph.BasicGr d

module GT.Generator.RandomGraph
barabasiAlbert :: Builder g d => Int -> Int -> Int -> (NodeId -> n) -> (NodeId -> NodeId -> PairWith NodeId e) -> IO (g n e d)

module GT.Algorithm.ShortestPath
dijkstra :: forall w g' t n e. (Ord w, Num w, EdgeAccessor g' t (NWith n) e) => (e -> w) -> NodeId -> NodeId -> g' -> Maybe (w, Seq NodeId)

module GT.Algorithm.Propagation
propagate :: forall n' g t e a. (Unwrap NodeId n', EdgeAccessor g t n' e) => (e -> Double) -> g -> (Set NodeId -> Set NodeId -> a -> a) -> a -> GenIO -> StateT (Set NodeId, Set NodeId) IO a
propagateUntil :: forall n' g t e a. (Unwrap NodeId n', EdgeAccessor g t n' e) => (e -> Double) -> g -> (Set NodeId -> Set NodeId -> a -> a) -> (a -> Bool) -> Set NodeId -> a -> Int -> IO (a, (Set NodeId, Set NodeId))

module GT.Algebra.Matrix
adjacencyMatrix :: forall n' e' g t. (Filterable t, Eq n', Unwrap (Pair n') e', Graph g t n' e') => g -> Matrix R
degreeMatrix :: forall n' e' g t. (Filterable t, Unwrap NodeId n', Graph g t n' e') => g -> Matrix R
laplacian :: forall n' e' g t. (Filterable t, Eq n', Unwrap NodeId n', Unwrap (Pair n') e', Graph g t n' e') => g -> Matrix R

module GT.Parse
parseGraphml :: Builder g d => (n -> n -> Ordering) -> (Int -> Map String Double -> n) -> (Int -> Int -> Int -> Map String Double -> PairWith NodeId e) -> String -> Maybe (g n e d)
